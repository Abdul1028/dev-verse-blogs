---
title: 'On Demand ISR Next JS'
date: '2025-05-16'
author: 'Abdul1028'
summary: 'How On demand ISR works on NextJS'
slug: 'on-demand-isr'
---

# Mastering On-Demand ISR in Next.js

Next.js revolutionized how we build fast, SEO-friendly web apps with **Incremental Static Regeneration (ISR)**. With the introduction of **On-Demand ISR**, we now have even finer control over when pages are regenerated â€” enabling real-time updates **without full redeployments**.

In this post, weâ€™ll dive into how On-Demand ISR works and how you can implement it in your Next.js app.

## ðŸ§  What Is ISR in Next.js?

**Incremental Static Regeneration (ISR)** allows you to update static pages **after deployment**. With ISR, you don't need to rebuild your entire app just to reflect changes in a single page.

There are two flavors:

- **Time-based ISR**: Uses `revalidate` time in `getStaticProps`
- **On-Demand ISR**: Pages are rebuilt on command (API call)

## âš™ï¸ Time-Based vs On-Demand ISR

| Feature             | Time-based ISR         | On-Demand ISR              |
|---------------------|------------------------|----------------------------|
| Trigger             | Timer (e.g., every 10s) | Manual via API call        |
| Best for            | Frequent updates        | Infrequent, important updates |
| Setup complexity    | Low                     | Medium                     |
| Flexibility         | Less                    | More                       |

## ðŸš€ Use Case for On-Demand ISR

Imagine you have a blog or CMS. When an admin updates a post, you want that postâ€™s static page to be regenerated **immediately** â€” not after a timeout.

This is where **On-Demand ISR** shines.

## ðŸ› ï¸ Setting Up On-Demand ISR in Next.js

### 1. Setup `getStaticProps` with `revalidate: false`

\`\`\`js
// pages/blog/[slug].tsx

export async function getStaticProps({ params }) {
  const post = await getPostBySlug(params.slug);

  return {
    props: { post },
    revalidate: false, // or omit it
  };
}
\`\`\`

### 2. Create the On-Demand ISR API Route

\`\`\`ts
// pages/api/revalidate.ts

export default async function handler(req, res) {
  const secret = req.query.secret;
  if (secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  const slug = req.body.slug;

  try {
    await res.revalidate(`/blog/${slug}`);
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send('Error revalidating');
  }
}
\`\`\`

### 3. Trigger the Revalidation

\`\`\`ts
await fetch('/api/revalidate?secret=MY_SECRET_TOKEN', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ slug: 'your-post-slug' })
});
\`\`\`

## ðŸ” Secure Your Revalidation

To prevent abuse, always use a **secret token** in your revalidation endpoint and store it in `.env`:

\`\`\`env
MY_SECRET_TOKEN=supersecret
\`\`\`

## âœ… Benefits of On-Demand ISR

- **Real-time updates** without full rebuilds
- **Better performance** with static pages
- **More control** over when updates happen
- Works well with headless CMSs like Sanity, Contentful, Strapi, etc.

## ðŸ§ª Pro Tips

- Log the `revalidated` response for debugging
- Use webhooks in your CMS to trigger the `/revalidate` endpoint
- You can revalidate multiple pages in a single call if needed

## ðŸ“¦ Bonus: Revalidate Multiple Routes

\`\`\`ts
const slugs = req.body.slugs || [];

await Promise.all(slugs.map((slug) => res.revalidate(`/blog/${slug}`)));
\`\`\`

## ðŸ§­ Conclusion

On-Demand ISR gives you the power of static generation with the flexibility of dynamic updates. It's perfect for content-heavy apps that need to reflect updates immediately without a full rebuild.

Next.js continues to push the boundaries of whatâ€™s possible with Jamstack and serverless.

## ðŸ“š Further Reading

- [Next.js ISR Docs](https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration)
- [Vercel Blog on ISR](https://vercel.com/blog/incremental-static-regeneration)